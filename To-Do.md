Things left to do:
- Smart contract
  - Name the app, then make the change everywhere
  - All attributes and functions have correct access classifiers (private/internal/public)
  - Use one specific version in the contracts, not a range (0.8.4)
  - Remove `import "hardhat/console.sol";` from all contracts
  - Ensure openzeppelin access control is used
    - Main admin which can control all roles in contracts
    - Each collection owner is an admin who can add/remove roles
  - Monetary
    - Add option for anyone to donate funds to the contract
    - Dividends
  - Make all error messages unique
  - Change contract name from `Sale` to `Transaction`
  - NFT contract `approve` one instead of `approve all`, give option to do both
  - Rename `Bank > CollectionAccount > reflectionVault` to `tokenVault`?
  - Transaction types
    - Transfer
      - Transfer of asset, no sale, commissions or incentives.
      - Use ERC721 functions to do a simple transfer from one account to another
    - Direct
      - Need to be careful with incentives for direct sales. Risk of users selling to their own wallets and making money.
    - Immediate
    - Auction
      - During the auction, buyer is not able to back out of (or cancel) the auction
      - What to do if no buyer is foind in an auction? Only then seller is able to `reclaim` their NFT.
  - Commissions
    - Have an upper cap of 99%, or no need?
    - Artist commission cap at 20%?
  - Incentives
    - Have an upper cap of 99%, or no need?
    - Have different configurable variables for marketplace incentives (direct / immediate / auction)
    - Need to be careful with incentives for direct sales. Risk of users selling to their own wallets and making money.
  - Address all `@todo` in the code
- Back-end
  - Database
    - Tables (per network)
      - user: User information
        - walletId, name, bio, picture, [notifications], timestamp
        - PK: walletId
        - LSI: timestamp ?
        - GSI: 
      <!-- - created-asset: NFTs created on the marketplace (do we need this? asset table can cover this?)
        - walletId, contractAddress, tokenId, commission, cid
        - PK: walletId, contractAddress
        - LSI: tokenId
        - GSI:  -->
      - contracts: All known contracts (need to be updated constantly)
        - [contractAddress], chain, name, symbol, isVerified::number
        - PK: arbitrary-number, chain
        - LSI: isVerified
        - GSI: 
      - collection: List of collections
        - contractAddress, id, name, totalSupply, reflection, commission, incentive, owner, collectionType, ownerIncentiveAccess, active::number, category
        - PK: id
        - LSI: 
        - GSI: category + active, owner + active (only get data that you need)
      - asset: List of assets
        - contractAddress, tokenId, collectionId, commission, creator, owner, cid
        - PK: contractAddress, tokenId
        - LSI: creator, owner
        - GSI: 
      - sales: List of assets on sale in marketplace
        - contractAddress, tokenId, id, collectionId, seller, buyer, price, sold, active::number, category
        - PK: id
        - LSI: 
        - GSI: category + active (only get data that you need)
      <!-- - assets: List of assets (NFT on sale or not) -->
        <!-- - contractAddress, tokenId, creator, owner,  -->
- Front-end dapp
  - Easy way to set ENV variables in docker image / k8s, for contract addresses, admin accounts, etc...
  - AWS
    - IAM
      - Dynamodb: Give only appropriate access as needed
      - Only access to add/remove items in tables
      - No access to create/delete tables
- Social media
  - Discord server
  - Twitter account
